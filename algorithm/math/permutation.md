# Next Permutation 下一个全排列
例如数组 [1, 2, 3] 能够生成的全部全排列为:
- [1, 2, 3]
- [1, 3, 2]
- [2, 1, 3]
- [2, 3, 1]
- [3, 1, 2]
- [3, 2, 1]

如果要找一个组合的下一个全排列，那么我们需要找下一个比当前大一点点🤏的数。

~~那么就是要把尾端的较大数往前移动。[1, 2, 3] 中尾端的加大数就是 3。然后将这个较大数与前端比较小的数进行一个交换，也就是 2 。~~

那么我就需要找到找到一个靠近前部的较小数来和其之后的一个比它稍微大一点的数来交换。

再找个稍复杂点的例子 [4,5,2,6,3,1] 我们开始从尾部寻找一个较小数，这个寻找的方法就是找到第一个满足 a[i] < a[i + 1] 的数，那么这个 a[i] 就是较小数，因为 [i + 1, n) 这一部分肯定是降序的，怎么换都不可能换出来一个更大一点的数。

后面，我们需要在 [i + 1, n) 的区间内从 n - 1 往 i + 1 去寻找 a[j] > a[i] 的数。这个数就是我们提到的较大数。

然后我们交换一下这两个数。在这里简单证明一下交换后 [i + 1, n) 这个区间仍处于一个降序。

---

在 [i + 1, n) 内均满足 a[m] > a[m + 1], a[j] 为区间内满足 a[j] > a[i] 下标最大的数。

因为 a[j - 1] > a[j] > a[i] > a[j + 1]

所以 a[j - 1] > a[i] > a[j + 1]

所以交换后仍为降序

---

回到例子 [4,5,2,6,3,1] 中较小数就是 2，再次从尾端遍历寻找较大数为 3 。那么交换后 [4, 5, 3, 6, 2, 1]

交换完成后再把 [i + 1, n) 区间反转，则就生成了以 a[j] 为首的最小数，满足题目要求。

那么 [4, 5, 3, 6, 2, 1] 就变为了 [4, 5, 3, 1, 2, 6] 。

需要注意的是如果第一步没有找到较小数则说明该组合已经是最大的，直接全部反转即可满足条件。


